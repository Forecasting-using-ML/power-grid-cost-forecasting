"""A generalized genetic algorithm."""
from typing import Callable
from tqdm import tqdm
from numpy import array
from pandas import DataFrame
from .parent_selection import ParentSelector
from .procreation import Procreator
from .mutation import Mutator
from .survivor_selection import SurvivorSelector


# the template string for the __repr__ method
TEMPLATE = """
GeneticAlgorithm(parent_selector={},
                 procreator={},
                 mutator={},
                 survivor_selector={},
                 maximize={})
""".lstrip()


class GeneticAlgorithm(object):
    """An implementation of the generalized genetic algorithm."""

    def __init__(self,
                 parent_selector: ParentSelector,
                 procreator: Procreator,
                 mutator: Mutator,
                 survivor_selector: SurvivorSelector,
                 maximize: bool=True):
        """
        Initialize a new Evolutionary aglorithm

        Args:
            parent_selector: the selector for picking parents
            procreator: the precreator for making children
            mutator: the mutator for mutating children
            survivor_selector: the selector for picking survivors
            maximize: whether to maximize the evaluation function (default True)
        """
        # type check parameters
        if not isinstance(parent_selector, ParentSelector):
            raise TypeError('parent_selector must be type ParentSelector!')
        if not isinstance(procreator, Procreator):
            raise TypeError('procreator must be type Procreator!')
        if mutator is not None and not isinstance(mutator, Mutator):
            raise TypeError('mutator must be type Mutator!')
        if not isinstance(survivor_selector, SurvivorSelector):
            raise TypeError('survivor_selector must be type SurvivorSelector!')
        # assign instance members
        self.parent_selector = parent_selector
        self.procreator = procreator
        self.mutator = mutator
        self.survivor_selector = survivor_selector
        self.maximize = maximize
        # the list of evaluated members
        self.evaluated = []


    def __repr__(self):
        """Return a string representation of this object."""
        return TEMPLATE.format(*[
            self.parent_selector,
            self.procreator,
            self.mutator,
            self.survivor_selector,
            self.maximize
        ])

    def _generation(self, population: list, iteration: int, callback: Callable=None):
        """
        Perform a generation  of evolution and return the new children.

        Args:
            population: the population to perform a generation on
            iteration: the current iteration in the algorithm
            callback: the callback method to use if any (default None)

        Returns: the children generated by the generation
        """
        # select parents
        parents = self.parent_selector.select(population, maximize=self.maximize)
        # procreate children
        children = self.procreator.procreate(parents)
        if self.mutator is not None:
            # mutate the children in place to save memory
            self.mutator.mutate(children, inplace=True)
        # select survivors in the population inplace
        self.survivor_selector.select(population, parents, children, maximize=self.maximize)
        if callable(callback):
            # pass the population and iteration number to the callback
            callback(population, iteration)
        return children

    # TODO: use __call__ instead of evolve. more pythonic given that the class
    # is called GeneticAlgorithm implying that it is callable
    def evolve(self,
               population: list,
               iterations: int=2000,
               inplace: bool=False,
               callback: Callable=None):
        """
        Evolve the population for the given number of iterations.

        Args:
            population: the population to evolve
            iterations: the number of iterations to run (default 2000)

        Returns: an evolved population of chromosomes
        """
        # reset the list of evaluated fitnesses to the current populations
        # fitnesses
        self.evaluated = [ind.copy() for ind in population]
        # if not evolving in place, copy the population first
        if not inplace:
            population = list(population)
        try:
            # iterate over the number of iterations
            for iteration in tqdm(range(iterations), unit='iteration'):
                for child in self._generation(population, iteration, callback):
                    self.evaluated.append(child.copy())
            return population
        except KeyboardInterrupt:
            return population

    @property
    def evaluated_fitnesses(self):
        """Return the fitnesses of the evaluated chromosomes."""
        return array([ind.fitness for ind in self.evaluated])

    def fitness_metrics(self, name: str='GeneticAlgorithm'):
        """Return a dataframe of fitness metrics over the evolution."""
        # calculate the midpoint of the index of evaluated indexes
        mid = int(len(self.evaluated) / 2)
        # split the evaluated fitnesses into groups: first half, second half,
        # total
        groups = [
            self.evaluated_fitnesses[:mid],
            self.evaluated_fitnesses[mid:],
            self.evaluated_fitnesses
        ]
        group_names = [
            '[0,{})'.format(mid),
            '[{},{})'.format(mid, len(self.evaluated)),
            'total'
        ]
        column_count = len(groups) * 2
        columns = array([('$\mu_{{{}}}$'.format(group_name), '$\sigma_{{{}}}$'.format(group_name)) for group_name in group_names]).reshape(column_count)
        metrics = array([(group.mean(), group.std()) for group in groups]).reshape(-1, column_count)
        # generate metrics for each group and return the dataframe formatted
        # with the metrics, index, and column names
        return DataFrame(metrics, columns=columns, index=[name])

# explicitly specify exports from module
__all__ = [
    'GeneticAlgorithm'
]
